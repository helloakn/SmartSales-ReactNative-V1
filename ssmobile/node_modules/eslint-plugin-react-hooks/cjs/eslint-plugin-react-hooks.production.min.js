/** @license React vundefined
 * eslint-plugin-react-hooks.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';function O(a){if("Identifier"===a.type)return/^use[A-Z0-9].*$/.test(a.name);if("MemberExpression"===a.type&&!a.computed&&O(a.property)){a=a.object;var c=/^[A-Z].*/;return"Identifier"===a.type&&c.test(a.name)}return!1}function aa(a){return"Identifier"===a.type?!/^[a-z]/.test(a.name):!1}function ba(a,c){return a.name===c||"MemberExpression"===a.type&&"React"===a.object.name&&a.property.name===c}function ea(a){return!!(a.parent&&a.parent.callee&&ba(a.parent.callee,"forwardRef"))}
function fa(a){return!!(a.parent&&a.parent.callee&&ba(a.parent.callee,"memo"))}function ha(a){for(;a;){var c=ia(a);if(c&&(aa(c)||O(c))||ea(a)||fa(a))return!0;a=a.parent}return!1}
function ia(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:
a.parent.key}
function ja(a){function c(){return{isUsed:!1,isSatisfiedRecursively:!1,isSubtreeUsed:!1,children:new Map}}function e(a,b){b=b.split(".");var m=!0,e=!1,f=void 0;try{for(var d=b[Symbol.iterator](),h;!(m=(h=d.next()).done);m=!0){var y=h.value,l=a.children.get(y);l||(l=c(),a.children.set(y,l));a=l}}catch(K){e=!0,f=K}finally{try{m||null==d.return||d.return()}finally{if(e)throw f;}}return a}function h(a,c,b){c=c.split(".");var m=!0,e=!1,f=void 0;try{for(var d=c[Symbol.iterator](),h;!(m=(h=d.next()).done);m=
!0){var l=a.children.get(h.value);if(!l)break;b(l);a=l}}catch(K){e=!0,f=K}finally{try{m||null==d.return||d.return()}finally{if(e)throw f;}}}function f(a,c,b,e){a.children.forEach(function(a,m){var d=e(m);a.isSatisfiedRecursively?a.isSubtreeUsed&&b.add(d):a.isUsed?c.add(d):f(a,c,b,function(a){return d+"."+a})})}var B=a.dependencies,k=a.declaredDependencies,q=a.stableDependencies,u=a.externalDependencies,v=a.isEffect,E=c();B.forEach(function(a,c){e(E,c).isUsed=!0;h(E,c,function(a){a.isSubtreeUsed=!0})});
k.forEach(function(a){e(E,a.key).isSatisfiedRecursively=!0});q.forEach(function(a){e(E,a).isSatisfiedRecursively=!0});a=new Set;var d=new Set;f(E,a,d,function(a){return a});var b=[],l=new Set,w=new Set;k.forEach(function(a){a=a.key;d.has(a)?-1===b.indexOf(a)?b.push(a):w.add(a):!v||a.endsWith(".current")||u.has(a)?l.add(a):-1===b.indexOf(a)&&b.push(a)});a.forEach(function(a){b.push(a)});return{suggestedDependencies:b,unnecessaryDependencies:l,duplicateDependencies:w,missingDependencies:a}}
function la(a){var c=a.declaredDependenciesNode,e=a.componentScope,h=a.scope;return a.declaredDependencies.map(function(a){a=e.set.get(a.key);if(null==a)return null;var c=a.defs[0];return null==c?null:"Variable"===c.type&&"VariableDeclarator"===c.node.type&&null!=c.node.init&&("ArrowFunctionExpression"===c.node.init.type||"FunctionExpression"===c.node.init.type)||"FunctionName"===c.type&&"FunctionDeclaration"===c.node.type?a:null}).filter(Boolean).map(function(a){var e=a.defs[0];a:{for(var f=!1,q=
0;q<a.references.length;q++){var u=a.references[q];if(u.writeExpr)if(f){a=!0;break a}else{f=!0;continue}for(var v=u.from;v!==h&&null!=v;)v=v.upper;if(v!==h&&!ma(c,u.identifier)){a=!0;break a}}a=!1}return{fn:e,suggestUseCallback:a}})}
function na(a){return"MemberExpression"!==a.parent.type&&"OptionalMemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||null!=a.parent.parent&&("CallExpression"===a.parent.parent.type||"OptionalCallExpression"===a.parent.parent.type)&&a.parent.parent.callee===a.parent?"MemberExpression"===a.type&&a.parent&&"AssignmentExpression"===a.parent.type&&a.parent.left===a?a.object:a:na(a.parent)}
function W(a,c){if("Identifier"===a.type)return a=a.name,c&&c.set(a,!1),a;if("MemberExpression"!==a.type||a.computed){if("OptionalMemberExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);var e=W(a.object,c),h=W(a.property,null);e=e+"."+h;c&&(a.optional?c.has(e)||c.set(e,!0):c.set(e,!1));return e}e=W(a.object,c);a=W(a.property,null);a=e+"."+a;c&&c.set(a,!1);return a}
function oa(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function qa(a,c){var e=oa(a);if("Identifier"!==e.type)return-1;switch(e.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(e===a&&c&&c.additionalHooks){try{var h=W(e,null)}catch(f){if(/Unsupported node type/.test(f.message))return 0;throw f;}return c.additionalHooks.test(h)?0:-1}return-1}}
function ra(a,c){for(var e=[a],h=null;e.length;){h=e.shift();if("Identifier"===h.type&&h.name===c.name&&h.range[0]===c.range[0]&&h.range[1]===c.range[1])return h;if(ma(h,c)){a=0;for(var f=Object.entries(h);a<f.length;a++){var B=f[a],k=B[1];"parent"!==B[0]&&(sa(k)?(k.parent=h,e.push(k)):Array.isArray(k)&&k.forEach(function(a){sa(a)&&(a.parent=h,e.push(a))}))}}}return null}
function ta(a){for(var c="",e=0;e<a.length;e++)c+=a[e],0===e&&2===a.length?c+=" and ":e===a.length-2&&2<a.length?c+=", and ":e<a.length-1&&(c+=", ");return c}function sa(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function ma(a,c){return a.range[0]<=c.range[0]&&a.range[1]>=c.range[1]}exports.configs={recommended:{plugins:["react-hooks"],rules:{"react-hooks/rules-of-hooks":"error","react-hooks/exhaustive-deps":"warn"}}};
exports.rules={"rules-of-hooks":{meta:{type:"problem",docs:{description:"enforces the Rules of Hooks",category:"Possible Errors",recommended:!0,url:"https://reactjs.org/docs/hooks-rules.html"}},create:function(a){var c=[],e=[];return{onCodePathSegmentStart:function(a){return e.push(a)},onCodePathSegmentEnd:function(){return e.pop()},onCodePathStart:function(){return c.push(new Map)},onCodePathEnd:function(e,f){function h(a,c){var b=h.cache,d=b.get(a.id);c=new Set(c);if(c.has(a.id)){b=[].concat(c);
a=b.slice(b.indexOf(a.id)+1);b=!0;d=!1;var l=void 0;try{for(var f=a[Symbol.iterator](),g;!(b=(g=f.next()).done);b=!0)v.add(g.value)}catch(G){d=!0,l=G}finally{try{b||null==f.return||f.return()}finally{if(d)throw l;}}return 0}c.add(a.id);if(void 0!==d)return d;if(e.thrownSegments.includes(a))d=0;else if(0===a.prevSegments.length)d=1;else{d=0;f=!0;g=!1;var L=void 0;try{l=a.prevSegments[Symbol.iterator]();for(var M;!(f=(M=l.next()).done);f=!0)d+=h(M.value,c)}catch(G){g=!0,L=G}finally{try{f||null==l.return||
l.return()}finally{if(g)throw L;}}}a.reachable&&0===d?b.delete(a.id):b.set(a.id,d);return d}function k(a,c){var d=k.cache,b=d.get(a.id);c=new Set(c);if(c.has(a.id)){d=Array.from(c);a=d.slice(d.indexOf(a.id)+1);d=!0;b=!1;var f=void 0;try{for(var l=a[Symbol.iterator](),g;!(d=(g=l.next()).done);d=!0)v.add(g.value)}catch(G){b=!0,f=G}finally{try{d||null==l.return||l.return()}finally{if(b)throw f;}}return 0}c.add(a.id);if(void 0!==b)return b;if(e.thrownSegments.includes(a))b=0;else if(0===a.nextSegments.length)b=
1;else{b=0;l=!0;g=!1;var L=void 0;try{f=a.nextSegments[Symbol.iterator]();for(var M;!(l=(M=f.next()).done);l=!0)b+=k(M.value,c)}catch(G){g=!0,L=G}finally{try{l||null==f.return||f.return()}finally{if(g)throw L;}}}d.set(a.id,b);return b}function q(a){var c=q.cache,b=c.get(a.id);if(null===b)return Infinity;if(void 0!==b)return b;c.set(a.id,null);if(0===a.prevSegments.length)b=1;else{b=Infinity;var d=!0,e=!1,l=void 0;try{for(var g=a.prevSegments[Symbol.iterator](),L;!(d=(L=g.next()).done);d=!0){var M=
q(L.value);M<b&&(b=M)}}catch(G){e=!0,l=G}finally{try{d||null==g.return||g.return()}finally{if(e)throw l;}}b+=1}c.set(a.id,b);return b}var u=c.pop();if(0!==u.size){var v=new Set;h.cache=new Map;k.cache=new Map;q.cache=new Map;var E=k(e.initialSegment),d=ia(f),b=ha(f),l=d?aa(d)||O(d):ea(f)||fa(f),w=Infinity,m=!0,y=!1,J=void 0;try{for(var A=e.finalSegments[Symbol.iterator](),p;!(m=(p=A.next()).done);m=!0){var ka=p.value;if(ka.reachable){var z=q(ka);z<w&&(w=z)}}}catch(F){y=!0,J=F}finally{try{m||null==
A.return||A.return()}finally{if(y)throw J;}}m=!0;y=!1;J=void 0;try{for(var r=u[Symbol.iterator](),T;!(m=(T=r.next()).done);m=!0){var K=T.value,C=K[0],x=K[1];if(C.reachable){var Y=0===C.nextSegments.length?w<=q(C):w<q(C),V=h(C)*k(C),P=v.has(C.id);u=!0;A=!1;p=void 0;try{for(var H=x[Symbol.iterator](),N;!(u=(N=H.next()).done);u=!0){var n=N.value;P&&a.report({node:n,message:'React Hook "'+a.getSource(n)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});
if(l){if(!P&&V!==E){var D='React Hook "'+a.getSource(n)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+(Y?" Did you accidentally call a React Hook after an early return?":"");a.report({node:n,message:D})}}else if(f.parent&&("MethodDefinition"===f.parent.type||"ClassProperty"===f.parent.type)&&f.parent.value===f){var Z='React Hook "'+a.getSource(n)+'" cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook function.';
a.report({node:n,message:Z})}else if(d){var R='React Hook "'+a.getSource(n)+'" is called in function "'+(a.getSource(d)+'" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter.');a.report({node:n,message:R})}else if("Program"===f.type){var S='React Hook "'+a.getSource(n)+'" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:n,message:S})}else if(b){var I=
'React Hook "'+a.getSource(n)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:n,message:I})}}}catch(F){A=!0,p=F}finally{try{u||null==H.return||H.return()}finally{if(A)throw p;}}}}}catch(F){y=!0,J=F}finally{try{m||null==r.return||r.return()}finally{if(y)throw J;}}}},CallExpression:function(a){if(O(a.callee)){var f=c[c.length-1],h=e[e.length-1],k=f.get(h);k||(k=[],f.set(h,k));k.push(a.callee)}}}}},"exhaustive-deps":{meta:{type:"suggestion",
docs:{description:"verifies the list of dependencies for Hooks like useEffect and similar",category:"Best Practices",recommended:!0,url:"https://github.com/facebook/react/issues/14920"},fixable:"code",schema:[{type:"object",additionalProperties:!1,enableDangerousAutofixThisMayCauseInfiniteLoops:!1,properties:{additionalHooks:{type:"string"},enableDangerousAutofixThisMayCauseInfiniteLoops:{type:"boolean"}}}]},create:function(a){function c(c){f&&Array.isArray(c.suggest)&&0<c.suggest.length&&(c.fix=
c.suggest[0].fix);a.report(c)}function e(a,c){return function(b){if(c.has(b))return c.get(b);var d=a(b);c.set(b,d);return d}}function h(d,b,f,h,m){function l(a){var c=!0,g=!1,b=void 0;try{for(var f=a.references[Symbol.iterator](),e;!(c=(e=f.next()).done);c=!0){var h=e.value;if(h.resolved&&B.has(h.resolved.scope)){var n=ra(d,h.identifier),k=na(n),w=W(k,Y),y;if(y=m&&"Identifier"===k.type&&("MemberExpression"===k.parent.type||"OptionalMemberExpression"===k.parent.type)&&!k.parent.computed&&"Identifier"===
k.parent.property.type&&"current"===k.parent.property.name){for(var p=h.from,r=!1;p.block!==d;)"function"===p.type&&(r=null!=p.block.parent&&"ReturnStatement"===p.block.parent.type),p=p.upper;y=r}y&&C.set(w,{reference:h,dependencyNode:k});if("TSTypeQuery"!==k.parent.type){var q=h.resolved.defs[0];if(null!=q&&(null==q.node||q.node.init!==d.parent)&&"TypeParameter"!==q.type)if(x.has(w))x.get(w).references.push(h);else{var t=h.resolved,u=T(t)||K(t);x.set(w,{isStable:u,references:[h]})}}}}}catch(da){g=
!0,b=da}finally{try{c||null==f.return||f.return()}finally{if(g)throw b;}}c=!0;g=!1;b=void 0;try{for(var v=a.childScopes[Symbol.iterator](),J;!(c=(J=v.next()).done);c=!0)l(J.value)}catch(da){g=!0,b=da}finally{try{c||null==v.return||v.return()}finally{if(g)throw b;}}}function w(a){a=a.split(".");for(var c="",g=0;g<a.length;g++){if(0!==g){var b=a.slice(0,g+1).join(".");b=!0===Y.get(b);c+=b?"?.":"."}c+=a[g]}return c}function A(a,c,b,d){return 0===a.size?null:(1<a.size?"":c+" ")+b+" "+(1<a.size?"dependencies":
"dependency")+": "+ta(Array.from(a).sort().map(function(a){return"'"+w(a)+"'"}))+(". Either "+d+" "+(1<a.size?"them":"it")+" or remove the dependency array.")}m&&d.async&&c({node:d,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching"});
for(var p=k.acquire(d),B=new Set,z=null,r=p.upper;r;){B.add(r);if("function"===r.type)break;r=r.upper}if(r){z=r;var T=e(function(a){if(!Array.isArray(a.defs))return!1;var c=a.defs[0];if(null==c||"VariableDeclarator"!==c.node.type)return!1;var b=c.node.init;if(null==b)return!1;for(;"TSAsExpression"===b.type;)b=b.expression;var g=c.node.parent;if(null==g&&(ra(z.block,c.node.id),g=c.node.parent,null==g))return!1;if("const"===g.kind&&"Literal"===b.type&&("string"===typeof b.value||"number"===typeof b.value||
null===b.value))return!0;if("CallExpression"!==b.type)return!1;b=b.callee;"MemberExpression"!==b.type||"React"!==b.object.name||null==b.property||b.computed||(b=b.property);if("Identifier"!==b.type)return!1;c=c.node.id;b=b.name;if("useRef"===b&&"Identifier"===c.type)return!0;if(("useState"===b||"useReducer"===b)&&"ArrayPattern"===c.type&&2===c.elements.length&&Array.isArray(a.identifiers)){if(c.elements[1]===a.identifiers[0]){if("useState"===b)for(a=a.references,b=0;b<a.length;b++)q.set(a[b].identifier,
c.elements[0]);return!0}if(c.elements[0]===a.identifiers[0]&&"useState"===b)for(a=a.references,c=0;c<a.length;c++)u.add(a[c].identifier)}return!1},v),K=e(function(a){if(!Array.isArray(a.defs))return!1;a=a.defs[0];if(null==a||null==a.node||null==a.node.id)return!1;var c=a.node,b=z.childScopes;a=null;var g;for(g=0;g<b.length;g++){var d=b[g],f=d.block;if("FunctionDeclaration"===c.type&&f===c||"VariableDeclarator"===c.type&&f.parent===c){a=d;break}}if(null==a)return!1;for(g=0;g<a.through.length;g++)if(c=
a.through[g],null!=c.resolved&&B.has(c.resolved.scope)&&!T(c.resolved))return!1;return!0},E),C=new Map,x=new Map,Y=new Map;l(p);C.forEach(function(a,b){var g=a.dependencyNode;a=a.reference.resolved.references;for(var d=!1,f=0;f<a.length;f++){var e=a[f].identifier.parent;if(null!=e&&"MemberExpression"===e.type&&!e.computed&&"Identifier"===e.property.type&&"current"===e.property.name&&"AssignmentExpression"===e.parent.type&&e.parent.left===e){d=!0;break}}d||c({node:g.parent.property,message:"The ref value '"+
b+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '"+(b+".current' to a variable inside the effect, and use that variable in the cleanup function.")})});var V=new Set,P=new Set;x.forEach(function(b,d){var g=b.references;b.isStable&&P.add(d);g.forEach(function(b){b.writeExpr&&(b=b.writeExpr,V.has(d)||(V.add(d),c({node:b,message:"Assignments to the '"+d+"' variable from inside React Hook "+(a.getSource(f)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ")+
(a.getSource(f)+".")})))})});if(!(0<V.size))if(b){var H=[],N=new Set;"ArrayExpression"!==b.type?c({node:b,message:"React Hook "+a.getSource(f)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):b.elements.forEach(function(b){if(null!==b)if("SpreadElement"===b.type)c({node:b,message:"React Hook "+a.getSource(f)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});
else{try{var d=W(b,null)}catch(pa){if(/Unsupported node type/.test(pa.message)){"Literal"===b.type?x.has(b.value)?c({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. Did you mean to include "+(b.value+" in the array instead?")}):c({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):c({node:b,message:"React Hook "+a.getSource(f)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});
return}throw pa;}for(var g=b;"MemberExpression"===g.type||"OptionalMemberExpression"===g.type;)g=g.object;var e=!z.through.some(function(a){return a.identifier===g});H.push({key:d,node:b});e||N.add(d)}});var n=ja({dependencies:x,declaredDependencies:H,stableDependencies:P,externalDependencies:N,isEffect:m});r=n.unnecessaryDependencies;var D=n.missingDependencies,Z=n.duplicateDependencies,R=n.suggestedDependencies;if(0===Z.size+D.size+r.size)la({declaredDependencies:H,declaredDependenciesNode:b,componentScope:z,
scope:p}).forEach(function(a){var d=a.fn;a=a.suggestUseCallback;var g="The '"+d.name.name+"' function makes the dependencies of "+(h+" Hook (at line "+b.loc.start.line+") change on every render.");g=a?g+(" To fix this, wrap the '"+(d.name.name+"' definition into its own useCallback() Hook.")):g+(" Move it inside the "+h+" callback. Alternatively, wrap the '"+(d.name.name+"' definition into its own useCallback() Hook."));var e;a&&"Variable"===d.type&&(e=[{desc:"Wrap the '"+d.name.name+"' definition into its own useCallback() Hook.",
fix:function(a){return[a.insertTextBefore(d.node.init,"useCallback("),a.insertTextAfter(d.node.init,")")]}}]);c({node:d.node,message:g,suggest:e})});else{!m&&0<D.size&&(R=ja({dependencies:x,declaredDependencies:[],stableDependencies:P,externalDependencies:N,isEffect:m}).suggestedDependencies);(function(){if(0===H.length)return!0;var a=H.map(function(a){return a.key}),b=a.slice().sort();return a.join(",")===b.join(",")})()&&R.sort();n="";if(0<r.size){var S=null;Array.from(r.keys()).forEach(function(a){null===
S&&a.endsWith(".current")&&(S=a)});if(null!==S)n=" Mutable values like '"+S+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<N.size){var I=Array.from(N)[0];p.set.has(I)||(n=" Outer scope values like '"+I+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!n&&D.has("props")){p=x.get("props");if(null==p)return;p=p.references;if(!Array.isArray(p))return;I=!0;for(var F=0;F<p.length;F++){var Q=ra(z.block,p[F].identifier);
if(!Q){I=!1;break}Q=Q.parent;if(null==Q){I=!1;break}if("MemberExpression"!==Q.type&&"OptionalMemberExpression"!==Q.type){I=!1;break}}I&&(n=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+(h+" call and refer to those specific props inside ")+(a.getSource(f)+"."))}if(!n&&0<D.size){var X=null;D.forEach(function(a){if(!X){var b=z.set.get(a),c=x.get(a);if(c.references[0].resolved===b&&(b=b.defs[0],null!=b&&null!=b.name&&
"Parameter"===b.type)){b=!1;for(var d,e=0;e<c.references.length;e++)if(d=c.references[e].identifier,null!=d&&null!=d.parent&&("CallExpression"===d.parent.type||"OptionalCallExpression"===d.parent.type)&&d.parent.callee===d){b=!0;break}b&&(X=a)}}});null!==X&&(n=" If '"+X+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!n&&0<D.size){var t=null;D.forEach(function(a){if(null===t)for(var b=x.get(a).references,c,d,e=0;e<b.length;e++){c=b[e].identifier;
for(d=c.parent;null!=d&&d!==z.block;){if("CallExpression"===d.type){var f=q.get(d.callee);if(null!=f){f.name===a?t={missingDep:a,setter:d.callee.name,form:"updater"}:u.has(c)?t={missingDep:a,setter:d.callee.name,form:"reducer"}:(c=b[e].resolved,null!=c&&(c=c.defs[0],null!=c&&"Parameter"===c.type&&(t={missingDep:a,setter:d.callee.name,form:"inlineReducer"})));break}}d=d.parent}if(null!==t)break}});if(null!==t)switch(t.form){case "reducer":n=" You can also replace multiple useState variables with useReducer if '"+
(t.setter+"' needs the current value of '")+(t.missingDep+"'.");break;case "inlineReducer":n=" If '"+t.setter+"' needs the current value of '"+(t.missingDep+"', you can also switch to useReducer instead of useState and read '")+(t.missingDep+"' in the reducer.");break;case "updater":n=" You can also do a functional update '"+t.setter+"("+t.missingDep.substring(0,1)+" => ...)' if you only need '"+t.missingDep+"' in the '"+(t.setter+"' call.");break;default:throw Error("Unknown case.");}}c({node:b,
message:"React Hook "+a.getSource(f)+" has "+(A(D,"a","missing","include")||A(r,"an","unnecessary","exclude")||A(Z,"a","duplicate","omit"))+n,suggest:[{desc:"Update the dependencies array to be: ["+R.map(w).join(", ")+"]",fix:function(a){return a.replaceText(b,"["+R.map(w).join(", ")+"]")}}]})}}else{var U=null;x.forEach(function(a,b){U||a.references.forEach(function(a){if(!U&&q.has(a.identifier)){for(a=a.from;"function"!==a.type;)a=a.upper;a.block===d&&(U=b)}})});if(U){var ca=ja({dependencies:x,declaredDependencies:[],
stableDependencies:P,externalDependencies:new Set,isEffect:!0}).suggestedDependencies;c({node:f,message:"React Hook "+h+" contains a call to '"+U+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+ca.join(", ")+("] as a second argument to the "+h+" Hook."),suggest:[{desc:"Add dependencies array: ["+ca.join(", ")+"]",fix:function(a){return a.insertTextAfter(d,", ["+ca.join(", ")+"]")}}]})}}}}var f=a.options&&a.options[0]&&a.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops||
!1,B={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0,enableDangerousAutofixThisMayCauseInfiniteLoops:f},k=a.getSourceCode().scopeManager,q=new WeakMap,u=new WeakSet,v=new WeakMap,E=new WeakMap;return{CallExpression:function(d){var b=qa(d.callee,B);if(-1!==b){var e=d.arguments[b],f=d.callee,m=oa(f).name,k=d.arguments[b+1];d=/Effect($|[^a-z])/g.test(m);if(k||d){switch(e.type){case "FunctionExpression":case "ArrowFunctionExpression":h(e,
k,f,m,d);return;case "Identifier":if(!k||k.elements&&k.elements.some(function(a){return a&&"Identifier"===a.type&&a.name===e.name}))return;b=a.getScope().set.get(e.name);if(null==b||null==b.defs)return;b=b.defs[0];if(!b||!b.node)break;if("Variable"!==b.type&&"FunctionName"!==b.type)break;switch(b.node.type){case "FunctionDeclaration":h(b.node,k,f,m,d);return;case "VariableDeclarator":if(b=b.node.init)switch(b.type){case "ArrowFunctionExpression":case "FunctionExpression":h(b,k,f,m,d);return}}break;
default:c({node:f,message:"React Hook "+m+" received a function whose dependencies are unknown. Pass an inline function instead."});return}c({node:f,message:"React Hook "+m+" has a missing dependency: '"+e.name+"'. Either include it or remove the dependency array.",suggest:[{desc:"Update the dependencies array to be: ["+e.name+"]",fix:function(a){return a.replaceText(k,"["+e.name+"]")}}]})}else"useMemo"!==m&&"useCallback"!==m||c({node:f,message:"React Hook "+m+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"})}}}}}};
