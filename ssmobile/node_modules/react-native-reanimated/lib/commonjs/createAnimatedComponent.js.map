{"version":3,"sources":["createAnimatedComponent.js"],"names":["NODE_MAPPING","Map","listener","data","component","get","viewTag","_updateFromNative","props","dummyListener","createAnimatedComponent","Component","prototype","isReactComponent","AnimatedComponent","React","constructor","_component","_invokeAnimatedPropsCallbackOnMount","setNativeProps","forceUpdate","_propsAnimated","__getValue","c","_attachProps","componentWillUnmount","_detachPropUpdater","__detach","_detachNativeEvents","componentDidMount","_animatedPropsCallback","setNativeView","_attachNativeEvents","_attachPropUpdater","_getEventViewRef","getScrollableNode","node","key","prop","AnimatedEvent","attachEvent","detachEvent","_reattachNativeEvents","prevProps","attached","Set","nextEvts","add","__nodeID","has","nextProps","oldPropsAnimated","set","size","ReanimatedEventEmitter","addListener","delete","removeAllListeners","componentDidUpdate","_filterNonAnimatedStyle","inputStyle","style","value","AnimatedValue","_startingValue","AnimatedNode","_filterNonAnimatedProps","inputProps","StyleSheet","flatten","render","platformProps","Platform","select","web","default","collapsable","_setComponentRef","getNode","displayName","name"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { findNodeHandle, Platform, StyleSheet } from 'react-native';\nimport ReanimatedEventEmitter from './ReanimatedEventEmitter';\n\nimport AnimatedEvent from './core/AnimatedEvent';\nimport AnimatedNode from './core/AnimatedNode';\nimport AnimatedValue from './core/AnimatedValue';\nimport { createOrReusePropsNode } from './core/AnimatedProps';\n\nimport invariant from 'fbjs/lib/invariant';\n\nconst NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  const component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {\n  // empty listener we use to assign to listener properties for which animated\n  // event is used.\n}\n\nexport default function createAnimatedComponent(Component) {\n  invariant(\n    typeof Component !== 'function' ||\n      (Component.prototype && Component.prototype.isReactComponent),\n    '`createAnimatedComponent` does not support stateless functional components; ' +\n      'use a class component instead.'\n  );\n\n  class AnimatedComponent extends React.Component {\n    _invokeAnimatedPropsCallbackOnMount = false;\n\n    constructor(props) {\n      super(props);\n      this._attachProps(this.props);\n    }\n\n    componentWillUnmount() {\n      this._detachPropUpdater();\n      this._propsAnimated && this._propsAnimated.__detach();\n      this._detachNativeEvents();\n    }\n\n    setNativeProps(props) {\n      this._component.setNativeProps(props);\n    }\n\n    componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated.setNativeView(this._component);\n      this._attachNativeEvents();\n      this._attachPropUpdater();\n    }\n\n    _getEventViewRef() {\n      // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n      return this._component.getScrollableNode\n        ? this._component.getScrollableNode()\n        : this._component;\n    }\n\n    _attachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    _detachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.detachEvent(node, key);\n        }\n      }\n    }\n\n    _reattachNativeEvents(prevProps) {\n      const node = this._getEventViewRef();\n      const attached = new Set();\n      const nextEvts = new Set();\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          nextEvts.add(prop.__nodeID);\n        }\n      }\n      for (const key in prevProps) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          if (!nextEvts.has(prop.__nodeID)) {\n            // event was in prev props but not in current props, we detach\n            prop.detachEvent(node, key);\n          } else {\n            // event was in prev and is still in current props\n            attached.add(prop.__nodeID);\n          }\n        }\n      }\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {\n          // not yet attached\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on native components\n    // If you want to animate a composite component, you need to re-render it.\n    // In this case, we have a fallback that uses forceUpdate.\n    _animatedPropsCallback = () => {\n      if (this._component == null) {\n        // AnimatedProps is created in will-mount because it's used in render.\n        // But this callback may be invoked before mount in async mode,\n        // In which case we should defer the setNativeProps() call.\n        // React may throw away uncommitted work in async mode,\n        // So a deferred call won't always be invoked.\n        this._invokeAnimatedPropsCallbackOnMount = true;\n      } else if (typeof this._component.setNativeProps !== 'function') {\n        this.forceUpdate();\n      } else {\n        this._component.setNativeProps(this._propsAnimated.__getValue());\n      }\n    };\n\n    _attachProps(nextProps) {\n      const oldPropsAnimated = this._propsAnimated;\n\n      this._propsAnimated = createOrReusePropsNode(\n        nextProps,\n        this._animatedPropsCallback,\n        oldPropsAnimated\n      );\n      // If prop node has been reused we don't need to call into \"__detach\"\n      if (oldPropsAnimated !== this._propsAnimated) {\n        // When you call detach, it removes the element from the parent list\n        // of children. If it goes to 0, then the parent also detaches itself\n        // and so on.\n        // An optimization is to attach the new elements and THEN detach the old\n        // ones instead of detaching and THEN attaching.\n        // This way the intermediate state isn't to go to 0 and trigger\n        // this expensive recursive detaching to then re-attach everything on\n        // the very next operation.\n        oldPropsAnimated && oldPropsAnimated.__detach();\n      }\n    }\n\n    _updateFromNative(props) {\n      this._component.setNativeProps(props);\n    }\n\n    _attachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.set(viewTag, this);\n      if (NODE_MAPPING.size === 1) {\n        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n      }\n    }\n\n    _detachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.delete(viewTag);\n      if (NODE_MAPPING.size === 0) {\n        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      this._attachProps(this.props);\n      this._reattachNativeEvents(prevProps);\n\n      this._propsAnimated.setNativeView(this._component);\n    }\n\n    _setComponentRef = c => {\n      if (c !== this._component) {\n        this._component = c;\n      }\n    };\n\n    _filterNonAnimatedStyle(inputStyle) {\n      const style = {};\n      for (const key in inputStyle) {\n        const value = inputStyle[key];\n        if (key !== 'transform') {\n          if (value instanceof AnimatedValue) {\n            style[key] = value._startingValue;\n          } else if (!(value instanceof AnimatedNode)) {\n            style[key] = value;\n          }\n        }\n      }\n      return style;\n    }\n\n    _filterNonAnimatedProps(inputProps) {\n      const props = {};\n      for (const key in inputProps) {\n        const value = inputProps[key];\n        if (key === 'style') {\n          props[key] = this._filterNonAnimatedStyle(StyleSheet.flatten(value));\n        } else if (value instanceof AnimatedEvent) {\n          // we cannot filter out event listeners completely as some components\n          // rely on having a callback registered in order to generate events\n          // alltogether. Therefore we provide a dummy callback here to allow\n          // native event dispatcher to hijack events.\n          props[key] = dummyListener;\n        } else if (value instanceof AnimatedValue) {\n          props[key] = value._startingValue;\n        } else if (!(value instanceof AnimatedNode)) {\n          props[key] = value;\n        }\n      }\n      return props;\n    }\n\n    render() {\n      const props = this._filterNonAnimatedProps(this.props);\n      const platformProps = Platform.select({\n        web: {},\n        default: { collapsable: false },\n      });\n      return (\n        <Component {...props} ref={this._setComponentRef} {...platformProps} />\n      );\n    }\n\n    // A third party library can use getNode()\n    // to get the node reference of the decorated component\n    getNode() {\n      return this._component;\n    }\n  }\n\n  AnimatedComponent.displayName = `AnimatedComponent(${Component.displayName ||\n    Component.name ||\n    'Component'})`;\n\n  return AnimatedComponent;\n}\n"]}