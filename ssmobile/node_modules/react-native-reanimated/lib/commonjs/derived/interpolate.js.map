{"version":3,"sources":["interpolate.js"],"names":["interpolateInternalSingleProc","value","inS","inE","outS","outE","progress","resultForNonZeroRange","result","interpolateInternalSingle","inputRange","outputRange","offset","interpolateInternal","length","Extrapolate","EXTEND","CLAMP","IDENTITY","checkNonDecreasing","name","arr","i","AnimatedNode","checkMinElements","checkValidNumbers","Number","isFinite","convertToRadians","entries","endsWith","parseFloat","Math","PI","interpolate","config","extrapolate","extrapolateLeft","extrapolateRight","left","right","output"],"mappings":"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","sourcesContent":["import {\n  lessThan,\n  multiply,\n  sub,\n  add,\n  divide,\n  greaterThan,\n  lessOrEq,\n  eq,\n} from '../operators';\nimport invariant from 'fbjs/lib/invariant';\n\nimport AnimatedNode from '../core/AnimatedNode';\nimport { createAnimatedCond as cond } from '../core/AnimatedCond';\nimport { createAnimatedFunction as proc } from '../core/AnimatedFunction';\n\nconst interpolateInternalSingleProc = proc(function(\n  value,\n  inS,\n  inE,\n  outS,\n  outE\n) {\n  const progress = divide(sub(value, inS), sub(inE, inS));\n  // logic below was made in order to provide a compatibility witn an Animated API\n  const resultForNonZeroRange = add(outS, multiply(progress, sub(outE, outS)));\n  const result = cond(\n    eq(inS, inE),\n    cond(lessOrEq(value, inS), outS, outE),\n    resultForNonZeroRange\n  );\n  return result;\n});\n\nfunction interpolateInternalSingle(value, inputRange, outputRange, offset) {\n  const inS = inputRange[offset];\n  const inE = inputRange[offset + 1];\n  const outS = outputRange[offset];\n  const outE = outputRange[offset + 1];\n  return interpolateInternalSingleProc(value, inS, inE, outS, outE);\n}\n\nfunction interpolateInternal(value, inputRange, outputRange, offset = 0) {\n  if (inputRange.length - offset === 2) {\n    return interpolateInternalSingle(value, inputRange, outputRange, offset);\n  }\n  return cond(\n    lessThan(value, inputRange[offset + 1]),\n    interpolateInternalSingle(value, inputRange, outputRange, offset),\n    interpolateInternal(value, inputRange, outputRange, offset + 1)\n  );\n}\n\nexport const Extrapolate = {\n  EXTEND: 'extend',\n  CLAMP: 'clamp',\n  IDENTITY: 'identity',\n};\n\nfunction checkNonDecreasing(name, arr) {\n  for (let i = 1; i < arr.length; ++i) {\n    // We can't validate animated nodes in JS.\n    if (arr[i] instanceof AnimatedNode || arr[i - 1] instanceof AnimatedNode)\n      continue;\n    invariant(\n      arr[i] >= arr[i - 1],\n      '%s must be monotonically non-decreasing. (%s)',\n      name,\n      arr\n    );\n  }\n}\n\nfunction checkMinElements(name, arr) {\n  invariant(\n    arr.length >= 2,\n    '%s must have at least 2 elements. (%s)',\n    name,\n    arr\n  );\n}\n\nfunction checkValidNumbers(name, arr) {\n  for (let i = 0; i < arr.length; i++) {\n    // We can't validate animated nodes in JS.\n    if (arr[i] instanceof AnimatedNode || typeof arr[i] !== 'number') continue;\n    invariant(\n      Number.isFinite(arr[i]),\n      '%s cannot include %s. (%s)',\n      name,\n      arr[i],\n      arr\n    );\n  }\n}\n\nfunction convertToRadians(outputRange) {\n  for (const [i, value] of outputRange.entries()) {\n    if (typeof value === 'string' && value.endsWith('deg')) {\n      outputRange[i] = parseFloat(value) * (Math.PI / 180);\n    }\n  }\n}\n\nexport default function interpolate(value, config) {\n  const {\n    inputRange,\n    outputRange,\n    extrapolate = Extrapolate.EXTEND,\n    extrapolateLeft,\n    extrapolateRight,\n  } = config;\n\n  checkMinElements('inputRange', inputRange);\n  checkValidNumbers('inputRange', inputRange);\n  checkMinElements('outputRange', outputRange);\n  checkValidNumbers('outputRange', outputRange);\n  checkNonDecreasing('inputRange', inputRange);\n  invariant(\n    inputRange.length === outputRange.length,\n    'inputRange and outputRange must be the same length.'\n  );\n\n  convertToRadians(outputRange);\n  const left = extrapolateLeft || extrapolate;\n  const right = extrapolateRight || extrapolate;\n  let output = interpolateInternal(value, inputRange, outputRange);\n\n  if (left === Extrapolate.EXTEND) {\n  } else if (left === Extrapolate.CLAMP) {\n    output = cond(lessThan(value, inputRange[0]), outputRange[0], output);\n  } else if (left === Extrapolate.IDENTITY) {\n    output = cond(lessThan(value, inputRange[0]), value, output);\n  }\n\n  if (right === Extrapolate.EXTEND) {\n  } else if (right === Extrapolate.CLAMP) {\n    output = cond(\n      greaterThan(value, inputRange[inputRange.length - 1]),\n      outputRange[outputRange.length - 1],\n      output\n    );\n  } else if (right === Extrapolate.IDENTITY) {\n    output = cond(\n      greaterThan(value, inputRange[inputRange.length - 1]),\n      value,\n      output\n    );\n  }\n\n  return output;\n}\n"]}