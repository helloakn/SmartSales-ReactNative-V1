{"version":3,"sources":["interpolate.test.js"],"names":["interpolate","AnimatedValue","jest","mock","value","it","expect","inputRange","outputRange","toThrowErrorMatchingSnapshot","Infinity","NaN"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,eAAxB;AACA,OAAOC,aAAP,MAA0B,uBAA1B;AAEAC,IAAI,CAACC,IAAL,CAAU,2BAAV;AACAD,IAAI,CAACC,IAAL,CAAU,qBAAV;AAEA,MAAMC,KAAK,GAAG,IAAIH,aAAJ,CAAkB,CAAlB,CAAd;AAEAI,EAAE,CAAC,0EAAD,EAA6E,MAAM;AACnFC,EAAAA,MAAM,CAAC,MACLN,WAAW,CAACI,KAAD,EAAQ;AACjBG,IAAAA,UAAU,EAAE,CAAC,CAAD,CADK;AAEjBC,IAAAA,WAAW,EAAE,CAAC,CAAD,EAAI,CAAJ;AAFI,GAAR,CADP,CAAN,CAKEC,4BALF;AAMAH,EAAAA,MAAM,CAAC,MACLN,WAAW,CAACI,KAAD,EAAQ;AACjBG,IAAAA,UAAU,EAAE,CAAC,CAAD,EAAI,CAAJ,CADK;AAEjBC,IAAAA,WAAW,EAAE,CAAC,CAAD;AAFI,GAAR,CADP,CAAN,CAKEC,4BALF;AAMD,CAbC,CAAF;AAeAJ,EAAE,CAAC,8DAAD,EAAiE,MAAM;AACvEC,EAAAA,MAAM,CAAC,MACLN,WAAW,CAACI,KAAD,EAAQ;AACjBG,IAAAA,UAAU,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CADK;AAEjBC,IAAAA,WAAW,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV;AAFI,GAAR,CADP,CAAN,CAKEC,4BALF;AAMD,CAPC,CAAF;AASAJ,EAAE,CAAC,+DAAD,EAAkE,MAAM;AACxEC,EAAAA,MAAM,CAAC,MACLN,WAAW,CAACI,KAAD,EAAQ;AACjBG,IAAAA,UAAU,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAOG,QAAP,CADK;AAEjBF,IAAAA,WAAW,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP;AAFI,GAAR,CADP,CAAN,CAKEC,4BALF;AAMAH,EAAAA,MAAM,CAAC,MACLN,WAAW,CAACI,KAAD,EAAQ;AACjBG,IAAAA,UAAU,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CADK;AAEjBC,IAAAA,WAAW,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAOG,GAAP;AAFI,GAAR,CADP,CAAN,CAKEF,4BALF;AAMD,CAbC,CAAF;AAeAJ,EAAE,CAAC,0DAAD,EAA6D,MAAM;AACnEC,EAAAA,MAAM,CAAC,MACLN,WAAW,CAACI,KAAD,EAAQ;AACjBG,IAAAA,UAAU,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CADK;AAEjBC,IAAAA,WAAW,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP;AAFI,GAAR,CADP,CAAN,CAKEC,4BALF;AAMD,CAPC,CAAF","sourcesContent":["import interpolate from './interpolate';\nimport AnimatedValue from '../core/AnimatedValue';\n\njest.mock('../ReanimatedEventEmitter');\njest.mock('../ReanimatedModule');\n\nconst value = new AnimatedValue(0);\n\nit('throws if inputRange or outputRange does not contain at least 2 elements', () => {\n  expect(() =>\n    interpolate(value, {\n      inputRange: [0],\n      outputRange: [0, 1],\n    })\n  ).toThrowErrorMatchingSnapshot();\n  expect(() =>\n    interpolate(value, {\n      inputRange: [0, 1],\n      outputRange: [0],\n    })\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('throws if inputRange and outputRange are not the same length', () => {\n  expect(() =>\n    interpolate(value, {\n      inputRange: [0, 1, 2],\n      outputRange: [0, 1, 2, 3],\n    })\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('throws if inputRange or outputRange contains an invalid value', () => {\n  expect(() =>\n    interpolate(value, {\n      inputRange: [0, 1, Infinity],\n      outputRange: [0, 1, 2],\n    })\n  ).toThrowErrorMatchingSnapshot();\n  expect(() =>\n    interpolate(value, {\n      inputRange: [0, 1, 2],\n      outputRange: [0, 1, NaN],\n    })\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('throws if inputRange is not monotonically non-decreasing', () => {\n  expect(() =>\n    interpolate(value, {\n      inputRange: [0, 1, 0],\n      outputRange: [0, 1, 2],\n    })\n  ).toThrowErrorMatchingSnapshot();\n});\n"]}